eigen(A)
eigen(A+diag(3))
diag(3)
eigen(A)
eigen(A+4*diag(3))
OPPERA <- readxl::read_excel('OPPERA-I_COPC.xlsx')
rm(list=ls())
library(readxl)
library(dplyr)
OPPERA <- readxl::read_excel('OPPERA-I_COPC.xlsx')
getwd()
2*0.5*0.5
0.05/0.5
0.05/2*0.4*(1-0.4)
0.05/2*0.4*(1-0.4)
0.05/(2*0.4*(1-0.4))
0.05/(2*0.3*(1-0.3))
0.05/(2*0.2*(1-0.2))
0.05/(2*0.1*(1-0.1))
0.05/0.5
0.15/0.5
0.15/(2*0.4*(1-0.4))
0.15/(2*0.1*(1-0.1))
0.15/(2*0.05*(1-0.05))
0.05/(2*0.05*(1-0.05))
0.05/(2*0.1*(1-0.1))
0.05/(2*0.3*(1-0.3))
0.05/(2*0.2*(1-0.2))
0.05/(2*0.1*(1-0.1))
0.05/(2*0.05*(1-0.05))
0.05/(2*0.02*(1-0.02))
0.05/(2*0.025*(1-0.025))
0.05/(2*0.05*(1-0.05))
0.05/(2*0.04*(1-0.04))
0.05/(2*0.03*(1-0.03))
A <- matrix(c(1,2,5, 0,4,5, -4,3,2), nrow = 3)
eigen(A)
A <- matrix(c(1,2,5, 0,4,5, 4,3,2), nrow = 3)
eigen(A)
A <- matrix(c(1,2,5, 3,4,5, 4,3,2), nrow = 3)
eigen(A)
A <- matrix(c(1,2,5, 3,4,5, 1,3,2), nrow = 3)
eigen(A)
A <- matrix(c(1,0,0,2,0,0,3,0,0), nrow = 3)
eigen(A)
A <- matrix(c(1,1,0,2,0,0,3,0,0), nrow = 3)
eigen(A)
A <- matrix(c(3,2,0,2,0,0,3,0,0), nrow = 3)
eigen(A)
x <- 1
y <- "desc"
typeof(x)
typeof(y)
type
z <- 1.1
typeof(z)
typeof(x)
savings = 100
result = 100 * 1.10 ** 7
print("I started with $" + savings + " and now have $" + result + ". Awesome!")
print(paste0("I started with $", savings, " and now have $" , result, ". Awesome!"))
paste0("I started with $", savings, " and now have $" , result, ". Awesome!")
paste0("I started with $", savings, " and now have $" , result, ". Awesome!")
typeof(savings)
word = 'Python'
word[1]
c(x,y) <- c(0,1)
i=2.4
print('The value of i is ',i)
print('The value of i is ',i)
install.packages("languageserver")
A = [1, 1; 1 1]
A = matrix(c(1, 1, 1,1), nrow=2)
A
solve(A)
eigen(A)
det(A)
A
A <-matrix(c(1,3,0,-2), nrow = 2)
A
eigen(A)
eigen(A)$vecotrs
eigen(A)$vectors
eigen(A)$vectors
A <-matrix(c(1,3,0,-2,0,1,4,0,1), nrow = 3)
A
eigen(A)
A <-matrix(c(1,3,0,-3,0,1,4,0,1), nrow = 3)
eigen(A)
A <-matrix(c(1,3,0,3,2,1,0,1,1), nrow = 3)
eigen(A)
eigen(A)$vectors
U <- eigen(A)$vectors
U %*% t(U)
t(U) %*% U
U
U %*% t(U)
U %*% diag(1) %*% t(U)
diag(1,3)
U %*% diag(1, 3) %*% t(U)
U %*% diag(c(1,2,3)) %*% t(U)
U %*% diag(c(2,2,2)) %*% t(U)
U %*% diag(c(2,4,1)) %*% t(U)
A <- matrix(c(1,2,2,1), nrow =2)
eigen(A)
eigen(2*A)
tol = 1e-5
alpha <- runif(3, -1, 1)
tol = 1e-5
alpha0 <- runif(3, -1, 1)
alpha <- runif(3, -1, 1)
tau0 <- runif(2, 0, 1)
tau <- runif(2, 0, 1)
2*max(abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol),
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol))
abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol)
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol))
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol)
max(abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol),
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol)
)
abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol)
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol)
2*max(abs(alpha - alpha0)/(abs(alpha) + abs(alpha0) + tol),
abs(tau - tau0)/(abs(tau) + abs(tau0) + tol)
)
library(GMAT)
library(GMMAT)
install.packages("GMMAT")
library(GMMAT)
remove.packages("GMMAT", lib="~/R/win-library/4.0")
library(devtools)
library(RcppArmadillo)
library(CompQuadForm)
library(foreach)
library(Matrix)
library(BiocManager)
install.packages("BiocManager")
library(testthat)
library(BiocManager)
BiocManager::install(c("SeqArray", "SeqVartools"))
j
BiocManager::install(c("SeqArray", "SeqVartools"))
BiocManager::install(c("SeqArray", "SeqVartools"))
BiocManager::install(c("SeqArray", "SeqVarTools"))
0.1 * (0.9^7*2 + 0.9*3 +2)
j <- seq(7, 0)
j
alpha <- 0.1
(1 - alpha)^j
Q <- alpha * sum((1 - alpha)^j * Reward)
Action <- c(1, 3, 2, 2, 3, 2, 1, 1)
Reward <- c(2, 1, 0, 2, 1, 4, 3, 2)
j <- seq(7, 0)
alpha <- 0.1
Q <- alpha * sum((1 - alpha)^j * Reward)
Q
alpha * sum((1 - alpha)^j * Reward * Action == 1)
Action == 1
(1 - alpha)^j * Reward * Action == 1
sum((1 - alpha)^j * Reward * (Action == 1))
alpha * sum((1 - alpha)^j * Reward * (Action == 1))
Q <- sapply(1:3, function(i) alpha * sum((1 - alpha)^j * Reward * (Action == i)))
Q
c(7/3, 6/3, 2/2) + sqrt(log(9)/c(3, 3, 2))
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6))
P
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
P
initstatedist = c(0.3, 0.3, 0.4)
sample(3, prob = initstatedist)
sample(1:3, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
sample(3, size = 1, prob = initstatedist)
replicate(sample(3, size = 1, prob = initstatedist), 10)
replicate(10, sample(3, size = 1, prob = initstatedist))
table(replicate(100, sample(3, size = 1, prob = initstatedist)))
table(replicate(100, sample(3, size = 1, prob = initstatedist)))/100
table(replicate(1000, sample(3, size = 1, prob = initstatedist)))/1000
table(replicate(1000, sample(3, size = 1, prob = initstatedist)))/1000
# Initial state
s = sample(3, size = 1, prob = initstatedist)
s
TransMat = P
nbper = 10
# Initial state
s = sample(3, size = 1, prob = initstatedist)
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i-1], ])
}
s
# Initial state
s = sample(3, size = 1, prob = initstatedist)
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i], ])
}
s
# Initial state
s = sample(3, size = 1, prob = initstatedist)
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i], ])
}
s
# Initial state
s = sample(3, size = 1, prob = initstatedist)
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i], ])
print(TransMat[s[i], ])
print(s[i+1])
}
size(P)
dim(P)
length(initstatedist)
# Initial state
s = sample(length(initstatedist), size = nbpaths, prob = initstatedist)
nbpaths = 5
# Initial state
s = sample(length(initstatedist), size = nbpaths, prob = initstatedist)
s
# Initial state
s = sapply(1:nbpaths,
sample(length(initstatedist), size = 1, prob = initstatedist)
)
sample(length(initstatedist), size = 1, prob = initstatedist)
nbpaths
# Initial state
s <- sapply(1:nbpaths,
function(i)
sample(length(initstatedist), size = 1, prob = initstatedist)
)
s
s <- s'
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i], ])
}
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
# Initial state
s <- sapply(1:nbpaths,
function(i)
sample(length(initstatedist), size = 1, prob = initstatedist)
)
s <- t(s)
s
# Initial state
s <- sapply(1:nbpaths,
function(i)
sample(length(initstatedist), size = 1, prob = initstatedist)
)
s
for (i in 1:nbper){
s[,i+1] <- sample(3, size = 1, prob = TransMat[s[,i], ])
}
# Initial state
s <- sapply(1:nbpaths,
function(i)
sample(length(initstatedist), size = 1, prob = initstatedist)
)
s
# Initial state
s <- matrix(nrow = nbpaths, ncol = nbper)
s
for (i in 1:nbper){
s[,i+1] <- sample(3, size = 1, prob = TransMat[s[,i], ])
}
# Initial state
s <- matrix(nrow = nbpaths, ncol = nbper)
s[,1] <- sample(length(initstatedist), size = 1, prob = initstatedist)
s
s[,1] <- sample(length(initstatedist), size = 1, prob = initstatedist)
s
s[,1] <- sample(length(initstatedist), size = 1, prob = initstatedist)
s
s[,1] <- sample(length(initstatedist), size = 1, prob = initstatedist)
s
# Initial state
s <- matrix(nrow = nbpaths, ncol = nbper)
s[,1] <- sample(length(initstatedist), size = nbpaths, prob = initstatedist)
# Initial state
s = sample(3, size = 1, prob = initstatedist)
for (i in 1:nbper){
s[i+1] <- sample(3, size = 1, prob = TransMat[s[i], ])
}
s
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
return(Markovpahts = a)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
i =1
s
rm(s)
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
return(Markovpahts = a)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
# Initialize output
s = matrix(nrow = nbpaths, ncol = nbper)
# Simulate trajectories
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
# Return a matrix containing the simulated Markov chain paths
return(Markovpaths = s)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
# Initialize output
s = matrix(nrow = nbpaths + 1, ncol = nbper + 1)
# Simulate trajectories
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
# Return a matrix containing the simulated Markov chain paths
return(Markovpaths = s)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
# Initialize output
s = matrix(nrow = nbpaths, ncol = nbper + 1)
# Simulate trajectories
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:nbper){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
# Return a matrix containing the simulated Markov chain paths
return(Markovpaths = s)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
}
SimulateMarkovChain <- function(TransMat, nbper, nbpaths, initstatedist, theseed){
# Set seed to obtain reproducible results
set.seed(theseed)
# Initialize output
s = matrix(nrow = nbpaths, ncol = nbper)
# Simulate trajectories
for (i in 1:nbpaths){
# Initial state
s[i, 1] = sample(3, size = 1, prob = initstatedist)
for (j in 1:(nbper - 1)){
s[i, j+1] <- sample(3, size = 1, prob = TransMat[s[i, j], ])
}
}
# Return a matrix containing the simulated Markov chain paths
return(Markovpaths = s)
}
P = matrix(c(0.7, 0.2, 0.1, 0.1, 0.6, 0.3, 0.2, 0.2, 0.6), nrow = 3)
SimulateMarkovChain(TransMat = P,
nbper = 10,
nbpaths = 5,
initstatedist = c(0.3, 0.3, 0.4),
theseed = 1025
)
alpha = 0.8
beta = 0.4
P = matrix(c((1 + alpha)/2, (2 - beta)/3, (1 - alpha)/2, (1 + beta)/3))
P = matrix(c((1 + alpha)/2, (2 - beta)/3, (1 - alpha)/2, (1 + beta)/3), nrow = 2)
P
P3 <- P^3
P3
P*P
P*P*P
P3 <- P^3
P3
P^3[1]
P^3[1]
P^3
P^3[1, ]
(P^3)
(P^3)[1]
(P^3)[1, 2]
P
8/15
P^3
P * P * P
P %*% P %*% P
P %*% P %*% P
P%^3%
P%^%3
P %^% 3
expm
P %*% P %*% P
M10 <- matrix(0, 40, 40)
for(i in 1:4) M10[(i-1)*10+(1:10), (i-1)*10+(1:10)] <- 1
M10
View(M10)
M10 <- matrix(0, 40, 40)
for(i in 1:4) M10[(i-1)*10+(1:10), (i-1)*10+(1:10)] <- 1
eigen(M10)
eigen(M10)$values
ncol
nrow
ncol
x <- c(1,2,3,4,5,6)
x
x[-1]
x[-1:4]
x[-c(1:4)]
x[-c(1:4)]
x[-(1:4)]
setwd()
getwd()
d
library(data.table)
covdf <- fread("covars_full.txt")
covdf <- fread("covars_full.txt")
setwd("~/Dropbox/McGill/Julien & Sahir/projects/PenalizedGLMM/data")
library(data.table)
covdf <- fread("covars_full.txt")
plot(covdf$PCA1[1:100], covdf$PCA2[1:100])
plot(covdf$PCA1[1:1000], covdf$PCA2[1:1000])
plot(covdf$PCA1[1:10000], covdf$PCA2[1:10000])
plot(covdf$PCA1[1:50000], covdf$PCA2[1:50000])
covdf$PCA1 > 300
sum(covdf$PCA1 > 300)
sum(covdf$PCA1 > 300, na.rm = T)
sum(covdf$PCA2 < -200, na.rm = T)
commandArgs
?commandArgs
